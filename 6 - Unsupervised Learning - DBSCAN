import numpy as np
import matplotlib.pyplot as plt
from sklearn.datasets import make_classification
from sklearn.preprocessing import StandardScaler
from sklearn.cluster import DBSCAN
from sklearn.metrics import silhouette_score

# generate random dataset
X, y = make_classification(
    n_samples = 500,
    n_features = 2,
    n_informative = 2,
    n_redundant = 0,
    n_clusters_per_class = 1,
    n_classes = 3,
    random_state = 42
)

# standard scale dataset for processing
x_scaled = StandardScaler().fit_transform(X)

# cluster dataset points using DBSCAN
# uses two parameters, eps (epsilon) and minimum samples to define shape of clusters
# larger eps have few large clusters, smaller eps have many small clusters and noise
# min_samples determines density threshold or number of points required for an eps-radius neighborhood
# larger min_samples will make DBSCAN stricter in clustering
eps = 0.25
min_samples = 30

# initialize dbscan with the two parameters
dbscan = DBSCAN(eps = eps, min_samples = min_samples)
# difference between DBSCAN and KMeans is that DBSCAN will not require specifying number of clusters
# KMeans also primarily determines round clusters, whereas DBSCAN fits more arbitrary shapes
# better at determining noise points

# fit dbscan to standardized dataset
labels = dbscan.fit_predict(x_scaled)
# classifies poinst into core point, border point, and noise point
# >= min_samples is core point
# < min_samples is border point
# noise cannot be reached from any core point within eps

labels

# display array of cluster labels corresponding to rows per index

# compute number of clusters given DBSCAN results
n_clusters = len(set(labels)) - (1 if -1 in labels else 0)

n_clusters

# display number of clusters in labels

# compute for silhouette scores to determine quality of clustering
if n_clusters > 1:
  score = silhouette_score(x_scaled, labels)
else:
  score = 0

# silhouette scores need at least 2 clusters, so n_clusters needs to be > 1
# range is -1 to 1, with 1 = very good clustering, and 0 = overlapping clusters, while negative = points assigned to wrong clusters

# display overall clustering of points using matplot
plt.figure(figsize = (6,5))
unique_labels = set(labels) # isolates unique values in labels array

colors = [plt.cm.tab10(each) for each in np.linspace (0,1, len(unique_labels))] 
# maps each value under unique_labels spaced between 0 and 1 to a distinct color
for k, col in zip(unique_labels, colors): 
# for loop for k value and corresponding colors
  if k == -1:
    col = [0, 0, 0, 0.6] # black, semi-transparent
    label = "Noise"
  else:
    label = f"Cluster {k+1}"

  mask = (labels == k) # select only points belonging to current k in loop
  x1x2 = x_scaled[mask] # create subset with selected cluster
  plt.scatter(x1x2[:,0], x1x2[:, 1], c = [col], label = label)
  # scatter uses first two features, col index 0 and 1, to plot in a 2d plane
  # uses corresponding color for the current k
  # labels used for legend since labels here corresponds to labels within for loop

plt.legend()
plt.show()

# display scatterplot graph of clusters + noise

float(score)

# display silhouette score
